const express = require('express');
const path = require('path');
const fs = require('fs');
const CryptoJS = require('crypto-js');
const SftpClient = require('ssh2-sftp-client'); // 引入 SFTP 客户端
const app = express();

const cors = require('cors');
app.use(cors());

const data_dir = path.join(__dirname, 'data');
if (!fs.existsSync(data_dir)) fs.mkdirSync(data_dir);

var multer = require('multer');
var forms = multer({limits: { fieldSize: 100*1024*1024 }});
app.use(forms.array()); 

const bodyParser = require('body-parser')
app.use(bodyParser.json({limit : '50mb' }));  
app.use(bodyParser.urlencoded({ extended: true }));

const api_root = process.env.API_ROOT ? process.env.API_ROOT.trim().replace(/\/+$/, '') : '';

// --- Metube 集成配置 (环境变量) ---
const METUBE_UUID = process.env.METUBE_UUID; 
const METUBE_PASSWORD = process.env.METUBE_PASSWORD; 
const METUBE_DOMAIN_FILTER = process.env.METUBE_DOMAIN_FILTER ? process.env.METUBE_DOMAIN_FILTER.split(',') : [];

// 1. 本地保存模式 (如果同一台服务器)
const METUBE_LOCAL_FILE = process.env.METUBE_COOKIE_FILE; 

// 2. 远程 SFTP 模式 (如果不同服务器)
const SFTP_HOST = process.env.SFTP_HOST;
const SFTP_PORT = process.env.SFTP_PORT || 22;
const SFTP_USER = process.env.SFTP_USER;
const SFTP_PASSWORD = process.env.SFTP_PASSWORD; // 密码认证
const SFTP_PRIVATE_KEY = process.env.SFTP_PRIVATE_KEY; // 或 密钥认证 (路径或内容)
const SFTP_REMOTE_PATH = process.env.SFTP_REMOTE_PATH; // 远程服务器上的绝对路径 e.g. /my_data/docker_data/metube/cookies/cookies.txt

// 辅助函数：将 Cookie 转换为 Netscape 格式
function cookiesToNetscape(cookieData) {
    let content = "# Netscape HTTP Cookie File\n# This file is generated by CookieCloud for Metube via SFTP\n\n";
    for (const domainKey in cookieData) {
        if (METUBE_DOMAIN_FILTER.length > 0) {
            let matched = false;
            for (const filter of METUBE_DOMAIN_FILTER) {
                if (domainKey.includes(filter.trim())) { matched = true; break; }
            }
            if (!matched) continue;
        }
        const cookies = cookieData[domainKey];
        if (Array.isArray(cookies)) {
            cookies.forEach(cookie => {
                const domain = cookie.domain;
                const flag = domain.startsWith('.') ? 'TRUE' : 'FALSE';
                const path = cookie.path || '/';
                const secure = cookie.secure ? 'TRUE' : 'FALSE';
                const expiration = cookie.expirationDate ? Math.floor(cookie.expirationDate) : 1893456000;
                const name = cookie.name;
                const value = cookie.value;
                content += `${domain}\t${flag}\t${path}\t${secure}\t${expiration}\t${name}\t${value}\n`;
            });
        }
    }
    return content;
}

// 异步处理 Metube 同步逻辑
async function handleMetubeSync(uuid, encrypted, crypto_type) {
    if (!METUBE_UUID || !METUBE_PASSWORD || uuid !== METUBE_UUID) return;

    console.log(`[Metube Sync] Processing update for UUID: ${uuid}`);
    try {
        const useType = crypto_type || 'legacy';
        const decryptedData = cookie_decrypt(uuid, encrypted, METUBE_PASSWORD, useType);
        
        if (decryptedData && decryptedData.cookie_data) {
            const netscapeCookies = cookiesToNetscape(decryptedData.cookie_data);
            
            // 方式一：本地写入 (原有逻辑)
            if (METUBE_LOCAL_FILE) {
                const targetDir = path.dirname(METUBE_LOCAL_FILE);
                if (!fs.existsSync(targetDir)) fs.mkdirSync(targetDir, { recursive: true });
                fs.writeFileSync(METUBE_LOCAL_FILE, netscapeCookies);
                console.log(`[Metube Sync] Local file written: ${METUBE_LOCAL_FILE}`);
            }

            // 方式二：SFTP 远程上传 (新增逻辑)
            if (SFTP_HOST && SFTP_USER && SFTP_REMOTE_PATH) {
                console.log(`[Metube Sync] Starting SFTP upload to ${SFTP_HOST}...`);
                const sftp = new SftpClient();
                try {
                    const connectConfig = {
                        host: SFTP_HOST,
                        port: parseInt(SFTP_PORT),
                        username: SFTP_USER,
                    };
                    if (SFTP_PASSWORD) connectConfig.password = SFTP_PASSWORD;
                    if (SFTP_PRIVATE_KEY) {
                        // 判断是文件路径还是直接的Key内容
                        if (SFTP_PRIVATE_KEY.includes('BEGIN')) {
                            connectConfig.privateKey = SFTP_PRIVATE_KEY;
                        } else if (fs.existsSync(SFTP_PRIVATE_KEY)) {
                            connectConfig.privateKey = fs.readFileSync(SFTP_PRIVATE_KEY);
                        }
                    }

                    await sftp.connect(connectConfig);
                    // 将字符串转换为 Buffer 上传
                    await sftp.put(Buffer.from(netscapeCookies), SFTP_REMOTE_PATH);
                    console.log(`[Metube Sync] Remote SFTP upload successful: ${SFTP_REMOTE_PATH}`);
                } catch (sftpErr) {
                    console.error(`[Metube Sync] SFTP Error:`, sftpErr.message);
                } finally {
                    await sftp.end();
                }
            }
        }
    } catch (e) {
        console.error(`[Metube Sync] Decrypt/Process Error:`, e);
    }
}
// ------------------------------------

app.all(`${api_root}/`, (req, res) => {
    res.send('Hello World!'+`API ROOT = ${api_root}`);
});

app.post(`${api_root}/update`, (req, res) => {
    const { encrypted, uuid, crypto_type } = req.body;
    if (!encrypted || !uuid) {
        res.status(400).send('Bad Request');
        return;
    }

    const file_path = path.join(data_dir, path.basename(uuid)+'.json');
    const content = JSON.stringify({"encrypted":encrypted, "crypto_type": crypto_type});
    fs.writeFileSync(file_path, content);

    // 触发同步逻辑 (不阻塞主响应)
    handleMetubeSync(uuid, encrypted, crypto_type);

    if( fs.readFileSync(file_path) == content )
        res.json({"action":"done"});
    else
        res.json({"action":"error"});
});

app.all(`${api_root}/get/:uuid`, (req, res) => {
    const { uuid } = req.params;
    if (!uuid) {
        res.status(400).send('Bad Request');
        return;
    }
    const file_path = path.join(data_dir, path.basename(uuid)+'.json');
    if (!fs.existsSync(file_path)) {
        res.status(404).send('Not Found');
        return;
    }
    const data = JSON.parse(fs.readFileSync(file_path));
    if( !data ) {
        res.status(500).send('Internal Serverless Error');
        return;
    } else {
        if( req.body.password ) {
            const useType = data.crypto_type || 'legacy';
            const parsed = cookie_decrypt( uuid, data.encrypted, req.body.password, useType );
            res.json(parsed);
        } else {
            res.json(data);
        }
    }
});

app.use(function (err, req, res, next) {
    console.error(err);
    res.status(500).send('Internal Serverless Error');
});

const port = 8088;
app.listen(port, () => {
    console.log(`Server start on http://localhost:${port}${api_root}`);
});

function cookie_decrypt( uuid, encrypted, password, crypto_type ) {
    crypto_type = crypto_type || 'legacy';
    if (crypto_type === 'aes-128-cbc-fixed') {
        const hash = CryptoJS.MD5(uuid+'-'+password).toString();
        const the_key = hash.substring(0, 16);
        const fixedIv = CryptoJS.enc.Hex.parse('00000000000000000000000000000000');
        const options = { iv: fixedIv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 };
        const decrypted = CryptoJS.AES.decrypt(encrypted, CryptoJS.enc.Utf8.parse(the_key), options).toString(CryptoJS.enc.Utf8);
        return JSON.parse(decrypted);
    } else {
        const the_key = CryptoJS.MD5(uuid+'-'+password).toString().substring(0,16);
        const decrypted = CryptoJS.AES.decrypt(encrypted, the_key).toString(CryptoJS.enc.Utf8);
        return JSON.parse(decrypted);
    }
}
