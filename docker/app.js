const express = require('express');
const path = require('path');
const fs = require('fs');
const CryptoJS = require('crypto-js'); // 确保引用在顶部，方便解密使用
const app = express();

const cors = require('cors');
app.use(cors());

const data_dir = path.join(__dirname, 'data');
// make dir if not exist
if (!fs.existsSync(data_dir)) fs.mkdirSync(data_dir);

var multer = require('multer');
var forms = multer({limits: { fieldSize: 100*1024*1024 }});
app.use(forms.array()); 

const bodyParser = require('body-parser')
app.use(bodyParser.json({limit : '50mb' }));  
app.use(bodyParser.urlencoded({ extended: true }));

const api_root = process.env.API_ROOT ? process.env.API_ROOT.trim().replace(/\/+$/, '') : '';

// --- 新增配置：Metube 集成环境变量 ---
const METUBE_UUID = process.env.METUBE_UUID; // 需要同步到 Metube 的用户 UUID
const METUBE_PASSWORD = process.env.METUBE_PASSWORD; // 该用户的解密密码
// 容器内的写入路径，将在 docker-compose 中映射到宿主机
const METUBE_COOKIE_FILE = process.env.METUBE_COOKIE_FILE || '/data/metube_cookies.txt'; 
// (可选) 仅导出包含这些关键词的域名，逗号分隔，留空导出所有
const METUBE_DOMAIN_FILTER = process.env.METUBE_DOMAIN_FILTER ? process.env.METUBE_DOMAIN_FILTER.split(',') : [];

// 辅助函数：将 Cookie 转换为 Netscape 格式 (cookies.txt)
function cookiesToNetscape(cookieData) {
    let content = "# Netscape HTTP Cookie File\n# This file is generated by CookieCloud for Metube\n\n";
    
    for (const domainKey in cookieData) {
        // 简单的域名过滤
        if (METUBE_DOMAIN_FILTER.length > 0) {
            let matched = false;
            for (const filter of METUBE_DOMAIN_FILTER) {
                if (domainKey.includes(filter.trim())) {
                    matched = true;
                    break;
                }
            }
            if (!matched) continue;
        }

        const cookies = cookieData[domainKey];
        if (Array.isArray(cookies)) {
            cookies.forEach(cookie => {
                // Netscape 格式: domain, flag, path, secure, expiration, name, value
                const domain = cookie.domain;
                // flag: TRUE if domain starts with .
                const flag = domain.startsWith('.') ? 'TRUE' : 'FALSE';
                const path = cookie.path || '/';
                const secure = cookie.secure ? 'TRUE' : 'FALSE';
                // 过期时间，如果没有则设为一个较远的未来 (例如 2030年)
                const expiration = cookie.expirationDate ? Math.floor(cookie.expirationDate) : 1893456000;
                const name = cookie.name;
                const value = cookie.value;

                content += `${domain}\t${flag}\t${path}\t${secure}\t${expiration}\t${name}\t${value}\n`;
            });
        }
    }
    return content;
}
// ------------------------------------

app.all(`${api_root}/`, (req, res) => {
    res.send('Hello World!'+`API ROOT = ${api_root}`);
});

app.post(`${api_root}/update`, (req, res) => {
    // 获取 crypto_type，兼容新版扩展
    const { encrypted, uuid, crypto_type } = req.body; 
    
    // none of the fields can be empty
    if (!encrypted || !uuid) {
        res.status(400).send('Bad Request');
        return;
    }

    // save encrypted to uuid file 
    const file_path = path.join(data_dir, path.basename(uuid)+'.json');
    // 保存时也保存 crypto_type
    const content = JSON.stringify({"encrypted": encrypted, "crypto_type": crypto_type});
    fs.writeFileSync(file_path, content);

    // --- 新增逻辑：检查是否需要导出给 Metube ---
    if (METUBE_UUID && METUBE_PASSWORD && uuid === METUBE_UUID) {
        console.log(`[Metube Sync] Detecting update for target UUID: ${uuid}`);
        try {
            // 使用请求中带的 crypto_type 或者默认为 legacy
            const useType = crypto_type || 'legacy';
            const decryptedData = cookie_decrypt(uuid, encrypted, METUBE_PASSWORD, useType);
            
            if (decryptedData && decryptedData.cookie_data) {
                const netscapeCookies = cookiesToNetscape(decryptedData.cookie_data);
                
                // 确保目标目录存在
                const targetDir = path.dirname(METUBE_COOKIE_FILE);
                if (!fs.existsSync(targetDir)) {
                    fs.mkdirSync(targetDir, { recursive: true });
                }

                fs.writeFileSync(METUBE_COOKIE_FILE, netscapeCookies);
                console.log(`[Metube Sync] Successfully wrote cookies to ${METUBE_COOKIE_FILE}`);
            }
        } catch (e) {
            console.error(`[Metube Sync] Error decrypting or saving cookies:`, e);
        }
    }
    // -------------------------------------------

    if( fs.readFileSync(file_path) == content )
        res.json({"action":"done"});
    else
        res.json({"action":"error"});
});

app.all(`${api_root}/get/:uuid`, (req, res) => {
    const { uuid } = req.params;
    // none of the fields can be empty
    if (!uuid) {
        res.status(400).send('Bad Request');
        return;
    }
    // get encrypted from uuid file
    const file_path = path.join(data_dir, path.basename(uuid)+'.json');
    if (!fs.existsSync(file_path)) {
        res.status(404).send('Not Found');
        return;
    }
    const data = JSON.parse(fs.readFileSync(file_path));
    if( !data )
    {
        res.status(500).send('Internal Serverless Error');
        return;
    }
    else
    {
        // 如果传递了password，则返回解密后的数据
        if( req.body.password )
        {
            // 兼容存储文件中的 crypto_type
            const useType = data.crypto_type || 'legacy';
            const parsed = cookie_decrypt( uuid, data.encrypted, req.body.password, useType );
            res.json(parsed);
        }else
        {
            res.json(data);
        }
    }
});


app.use(function (err, req, res, next) {
    console.error(err);
    res.status(500).send('Internal Serverless Error');
});


const port = 8088;
app.listen(port, () => {
    console.log(`Server start on http://localhost:${port}${api_root}`);
});

// 更新了解密函数以支持 'aes-128-cbc-fixed' 算法（新版扩展使用）
function cookie_decrypt( uuid, encrypted, password, crypto_type )
{
    // 如果没有传类型，默认为旧版
    crypto_type = crypto_type || 'legacy';

    if (crypto_type === 'aes-128-cbc-fixed') {
        const hash = CryptoJS.MD5(uuid+'-'+password).toString();
        const the_key = hash.substring(0, 16);
        const fixedIv = CryptoJS.enc.Hex.parse('00000000000000000000000000000000');
        const options = {
            iv: fixedIv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        };
        const decrypted = CryptoJS.AES.decrypt(encrypted, CryptoJS.enc.Utf8.parse(the_key), options).toString(CryptoJS.enc.Utf8);
        return JSON.parse(decrypted);
    } else {
        // Legacy 模式
        const the_key = CryptoJS.MD5(uuid+'-'+password).toString().substring(0,16);
        const decrypted = CryptoJS.AES.decrypt(encrypted, the_key).toString(CryptoJS.enc.Utf8);
        return JSON.parse(decrypted);
    }
}
